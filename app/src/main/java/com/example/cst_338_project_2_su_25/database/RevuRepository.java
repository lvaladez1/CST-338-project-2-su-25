package com.example.cst_338_project_2_su_25.database;

import android.app.Application;
import android.util.Log;

import androidx.lifecycle.LiveData;

import com.example.cst_338_project_2_su_25.DisplayFavoritesActivity;
import com.example.cst_338_project_2_su_25.entities.Favorites;
import com.example.cst_338_project_2_su_25.entities.MediaTitle;
import com.example.cst_338_project_2_su_25.entities.Review;

import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

/**
 * RevuRepository
 *
 * <p> This class acts as a centralized data access point for Room database operations,
 * abstracting the underlying data sources such as DAOs for use in the application.
 *
 * <p> This repository provides methods to perform CRUD operations on MediaTitle,
 * Favorites, and Review entities. It manages threading and data retrieval,
 * helping maintain a clean separation of concerns between UI and data layers.
 */
public class RevuRepository {

    private final MediaTitleDAO mediaTitleDAO;

    private final FavoritesDAO favoritesDAO;

    private final ExecutorService executorService;

    private static RevuRepository repository;

    private final ReviewDao reviewDao;

    /**
     * Private constructor for RevuRepository.
     * Initializes the Room database and obtains an instance of FavoritesDAO.
     * Also sets up a single-threaded executor for background operations.
     *
     * @param application The application context used to initialize the Room database.
     */
    private RevuRepository(Application application) {
        RevuDatabase db = RevuDatabase.getDatabase(application);

        this.mediaTitleDAO = db.mediaTitleDAO();
        this.reviewDao = db.reviewDao();
        this.favoritesDAO = db.favoritesDAO();

        executorService = Executors.newSingleThreadExecutor();
    }

    /**
     * Returns a singleton instance of the RevuRepository, creating it if necessary.
     *
     * <p> The instance is retrieved asynchronously using Future to support background thread initialization.
     *
     * @param application The application context.
     * @return The singleton RevuRepository instance, or null if initialization fails.
     */
    public static RevuRepository getRepository(Application application) {
        if (repository != null) {
            return repository;
        }
        Future<RevuRepository> future = RevuDatabase.databaseWriteExecutor.submit(
                new Callable<RevuRepository>() {
                    @Override
                    public RevuRepository call() throws Exception {
                        return new RevuRepository(application);
                    }
                }
        );
        try {
            return future.get();
        } catch (InterruptedException | ExecutionException e) {
            Log.d("Help!", "Problem getting RevuRepository, thread error.");
        }
        return null;
    }

    /**
     * Inserts a MediaTitle into the database and returns its autogenerated row ID.
     * This method blocks until the insert operation completes.
     *
     * @param mediaTitle The media title to insert.
     * @return The row ID of the newly inserted media title, or -1 if insertion fails.
     */
   public long insertMediaTitle(MediaTitle mediaTitle) {
       try {
           // submit the DAO.insert() and then wait for its return value
           return RevuDatabase.databaseWriteExecutor.submit(() ->
                           mediaTitleDAO.insert(mediaTitle)).get();
       } catch (Exception e) {
           Log.e("RevuRepository", "Failed to insert MediaTitle", e);
           return -1;
       }
   }

    /**
     * Inserts a Review into the database using a background thread.
     *
     * @param review The review to insert.
     */
    public void insertReview(Review review) {
        Executors.newSingleThreadExecutor().execute(() -> {
            reviewDao.insert(review);
        });
    }

    /**
     * Updates an existing Review in the database using a background thread.
     *
     * @param review The review to update.
     */
    public void updateReview(Review review) {
        Executors.newSingleThreadExecutor().execute(() -> {
            reviewDao.update(review);
        });
    }

    /**
     * Deletes a Review from the database using a background thread.
     *
     * @param review The review to delete.
     */
    public void deleteReview(Review review) {
        Executors.newSingleThreadExecutor().execute(() -> {
            reviewDao.delete(review);
        });
    }

    /**
     * Adds a favorite title to the Room database using a background thread.
     *
     * @param favorite The Favorites object to be inserted into the database.
     */
    //will switch to livedata later so UI can auto update
    public void addFavorite(Favorites favorite) {
        executorService.execute(() -> favoritesDAO.addFavorite(favorite));
    }

    /**
     * Removes a favorite title from the Room database using a background thread.
     *
     * @param favorite The Favorites object to be deleted from the database.
     */
    //will switch to livedata later so UI can auto update
    public void removeFavorite(Favorites favorite) {
        executorService.execute(() -> favoritesDAO.removeFavorite(favorite));
    }

    /**
     * Retrieves a LiveData list of Favorites for the specified user ID.
     * This allows the UI to observe changes to the user's favorites in real time.
     *
     * @param userId The ID of the user whose favorites are being requested.
     * @return A LiveData list of the user's favorite titles from the Room database.
     */
    public LiveData<List<Favorites>> getFavoritesForUser(int userId) {
        return favoritesDAO.getFavoritesForUser(userId);
    }

    /**
     * Retrieves all TV shows created by the specified user.
     *
     * @param userId The ID of the user.
     * @return A LiveData list of MediaTitle objects categorized as "tvShow".
     */
    public LiveData<List<MediaTitle>> getAllTvShowsByUserId(int userId) {
        return mediaTitleDAO.getAllTvShows(userId, "tvShow");
    }

    /**
     * Retrieves all movies created by the specified user.
     *
     * @param userId The ID of the user.
     * @return A LiveData list of MediaTitle objects categorized as "movie".
     */
    public LiveData<List<MediaTitle>> getAllMoviesByUserId(int userId) {
        return mediaTitleDAO.getAllMovies(userId, "movie");
    }

    /**
     * Retrieves a specific MediaTitle by its ID.
     *
     * @param mediaTitleId The unique ID of the media title.
     * @return The corresponding MediaTitle object, or null if not found.
     */
    public MediaTitle getMediaTitleById ( int mediaTitleId){

        return mediaTitleDAO.getMediaTitleById(mediaTitleId);

    }

//    public LiveData<List<DisplayFavoritesActivity>> getFavoriteDisplayForUser(int userId) {
//        return favoritesDAO.getFavoriteDisplayForUser(userId);
//    }
}

